{"ast":null,"code":"import dates from './dates'; // assumes both are supported or none\n\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor({\n    culture = undefined,\n    firstOfWeek = 0\n  } = {}) {\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date, format = {\n    dateStyle: 'short',\n    timeStyle: 'short'\n  }) {\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    return new Date(value);\n  }\n\n}\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\n\n\nclass IntlNumberLocalizer {\n  constructor({\n    culture = undefined\n  } = {}) {\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };","map":{"version":3,"sources":["C:/Users/Kainar_malay/Desktop/git_partfolio/kainar_present/first_react/node_modules/react-widgets/esm/IntlLocalizer.js"],"names":["dates","supportStyles","Intl","DateTimeFormat","undefined","dateStyle","dateShort","day","month","year","timeShort","hour","minute","getFormatter","culture","options","format","IntlDateLocalizer","constructor","firstOfWeek","normalizeFormat","date","toLocaleString","formats","time","timeStyle","datetime","Object","assign","header","weekday","dayOfMonth","decade","endOf","century","keys","forEach","key","toFormattedParts","formatToParts","filter","p","type","parse","value","Date","IntlNumberLocalizer","_$toLocaleString$m","decimal","NumberFormat","match","formatter","decimalCharacter","num","parseFloat","replace","DateLocalizer","NumberLocalizer"],"mappings":"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","sourcesContent":["import dates from './dates';\n// assumes both are supported or none\nlet supportStyles = false;\nnew Intl.DateTimeFormat(undefined, {\n  // @ts-ignore\n  get dateStyle() {\n    supportStyles = true;\n  }\n\n});\nconst dateShort = {\n  day: 'numeric',\n  month: 'numeric',\n  year: 'numeric'\n};\nconst timeShort = {\n  hour: 'numeric',\n  minute: 'numeric'\n};\n\nconst getFormatter = (culture, options) => Intl.DateTimeFormat(culture, options).format;\n/**\n * A `react-widgets` Localizer using native `Intl` APIs.\n *\n */\n\n\nclass IntlDateLocalizer {\n  constructor({\n    culture = undefined,\n    firstOfWeek = 0\n  } = {}) {\n    this.culture = culture;\n\n    this.firstOfWeek = () => firstOfWeek;\n\n    function normalizeFormat(date, format) {\n      return typeof format === 'function' ? format(date, culture) : date.toLocaleString(culture, format);\n    }\n\n    const formats = {\n      date: getFormatter(culture, supportStyles ? {\n        dateStyle: 'short'\n      } : dateShort),\n      time: getFormatter(culture, supportStyles ? {\n        timeStyle: 'short'\n      } : timeShort),\n      datetime: getFormatter(culture, supportStyles ? {\n        dateStyle: 'short',\n        timeStyle: 'short'\n      } : Object.assign({}, dateShort, timeShort)),\n      header: getFormatter(culture, {\n        month: 'short',\n        year: 'numeric'\n      }),\n      weekday: getFormatter(culture, {\n        weekday: 'narrow'\n      }),\n      dayOfMonth: getFormatter(culture, {\n        day: '2-digit'\n      }),\n      month: getFormatter(culture, {\n        month: 'short'\n      }),\n      year: getFormatter(culture, {\n        year: 'numeric'\n      }),\n      decade: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'decade'))}`,\n      century: date => `${this.year(date)} - ${this.year(dates.endOf(date, 'century'))}`\n    };\n    Object.keys(formats).forEach(key => {\n      this[key] = (date, format) => format ? normalizeFormat(date, format) : formats[key](date);\n    });\n  }\n\n  toFormattedParts(date, format = {\n    dateStyle: 'short',\n    timeStyle: 'short'\n  }) {\n    return Intl.DateTimeFormat(this.culture, format).formatToParts(date).filter(p => p.type !== 'timeZoneName');\n  }\n\n  parse(value) {\n    return new Date(value);\n  }\n\n}\n\n/**\n * A number localization strategy based on `Intl.NumberFormat`.\n */\nclass IntlNumberLocalizer {\n  constructor({\n    culture = undefined\n  } = {}) {\n    var _$toLocaleString$m;\n\n    this.culture = culture;\n    const decimal = 'formatToParts' in Intl.NumberFormat(culture) ? Intl.NumberFormat(culture).formatToParts(1.1)[1].value : ((_$toLocaleString$m = 1.1.toLocaleString(culture).match(/[^\\d]/)) == null ? void 0 : _$toLocaleString$m[0]) || '.';\n    const formatter = Intl.NumberFormat(culture).format;\n\n    this.decimalCharacter = () => decimal;\n\n    this.format = (num, format) => {\n      if (format) {\n        return typeof format === 'function' ? format(num, culture) : num.toLocaleString(culture, format);\n      }\n\n      return formatter(num);\n    };\n  }\n\n  parse(value) {\n    return parseFloat(value.replace(this.decimalCharacter(), '.'));\n  }\n\n}\n\nexport { IntlDateLocalizer as DateLocalizer, IntlNumberLocalizer as NumberLocalizer };"]},"metadata":{},"sourceType":"module"}