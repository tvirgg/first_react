{"ast":null,"code":"import useCustomEffect from './useCustomEffect';\nimport isEqual from \"lodash-es/isEqual\";\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\n\nfunction isDepsEqual(_ref, _ref2) {\n  var nextElement = _ref[0],\n      nextConfig = _ref[1];\n  var prevElement = _ref2[0],\n      prevConfig = _ref2[1];\n  return nextElement === prevElement && isEqual(nextConfig, prevConfig);\n}\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```ts\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n\nfunction useMutationObserver(element, config, callback) {\n  var fn = useEventCallback(callback);\n  useCustomEffect(function () {\n    if (!element) return; // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n\n    var observer = new MutationObserver(fn);\n    observer.observe(element, config);\n    return function () {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n}\n\nexport default useMutationObserver;","map":{"version":3,"sources":["C:/Users/Kainar_malay/Desktop/git_partfolio/kainar_present/first_react/node_modules/react-widgets/node_modules/@restart/hooks/esm/useMutationObserver.js"],"names":["useCustomEffect","isEqual","useImmediateUpdateEffect","useEventCallback","isDepsEqual","_ref","_ref2","nextElement","nextConfig","prevElement","prevConfig","useMutationObserver","element","config","callback","fn","observer","MutationObserver","observe","disconnect","effectHook"],"mappings":"AAAA,OAAOA,eAAP,MAA4B,mBAA5B;AACA,OAAOC,OAAP,MAAoB,mBAApB;AACA,OAAOC,wBAAP,MAAqC,4BAArC;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;;AAEA,SAASC,WAAT,CAAqBC,IAArB,EAA2BC,KAA3B,EAAkC;AAChC,MAAIC,WAAW,GAAGF,IAAI,CAAC,CAAD,CAAtB;AAAA,MACIG,UAAU,GAAGH,IAAI,CAAC,CAAD,CADrB;AAEA,MAAII,WAAW,GAAGH,KAAK,CAAC,CAAD,CAAvB;AAAA,MACII,UAAU,GAAGJ,KAAK,CAAC,CAAD,CADtB;AAEA,SAAOC,WAAW,KAAKE,WAAhB,IAA+BR,OAAO,CAACO,UAAD,EAAaE,UAAb,CAA7C;AACD;AACD;;;;;;;;;;;;;;;;;;;;;;AAsBA,SAASC,mBAAT,CAA6BC,OAA7B,EAAsCC,MAAtC,EAA8CC,QAA9C,EAAwD;AACtD,MAAIC,EAAE,GAAGZ,gBAAgB,CAACW,QAAD,CAAzB;AACAd,EAAAA,eAAe,CAAC,YAAY;AAC1B,QAAI,CAACY,OAAL,EAAc,OADY,CACJ;AACtB;AACA;AACA;;AAEA,QAAII,QAAQ,GAAG,IAAIC,gBAAJ,CAAqBF,EAArB,CAAf;AACAC,IAAAA,QAAQ,CAACE,OAAT,CAAiBN,OAAjB,EAA0BC,MAA1B;AACA,WAAO,YAAY;AACjBG,MAAAA,QAAQ,CAACG,UAAT;AACD,KAFD;AAGD,GAXc,EAWZ,CAACP,OAAD,EAAUC,MAAV,CAXY,EAWO;AACpBZ,IAAAA,OAAO,EAAEG,WADW;AAEpB;AACA;AACAgB,IAAAA,UAAU,EAAElB;AAJQ,GAXP,CAAf;AAiBD;;AAED,eAAeS,mBAAf","sourcesContent":["import useCustomEffect from './useCustomEffect';\nimport isEqual from \"lodash-es/isEqual\";\nimport useImmediateUpdateEffect from './useImmediateUpdateEffect';\nimport useEventCallback from './useEventCallback';\n\nfunction isDepsEqual(_ref, _ref2) {\n  var nextElement = _ref[0],\n      nextConfig = _ref[1];\n  var prevElement = _ref2[0],\n      prevConfig = _ref2[1];\n  return nextElement === prevElement && isEqual(nextConfig, prevConfig);\n}\n/**\n * Observe mutations on a DOM node or tree of DOM nodes.\n * Depends on the `MutationObserver` api.\n *\n * ```ts\n * const [element, attachRef] = useCallbackRef(null);\n *\n * useMutationObserver(element, { subtree: true }, (records) => {\n *\n * });\n *\n * return (\n *   <div ref={attachRef} />\n * )\n * ```\n *\n * @param element The DOM element to observe\n * @param config The observer configuration\n * @param callback A callback fired when a mutation occurs\n */\n\n\nfunction useMutationObserver(element, config, callback) {\n  var fn = useEventCallback(callback);\n  useCustomEffect(function () {\n    if (!element) return; // The behavior around reusing mutation observers is confusing\n    // observing again _should_ disable the last listener but doesn't\n    // seem to always be the case, maybe just in JSDOM? In any case the cost\n    // to redeclaring it is gonna be fairly low anyway, so make it simple\n\n    var observer = new MutationObserver(fn);\n    observer.observe(element, config);\n    return function () {\n      observer.disconnect();\n    };\n  }, [element, config], {\n    isEqual: isDepsEqual,\n    // Intentionally done in render, otherwise observer will miss any\n    // changes made to the DOM during this update\n    effectHook: useImmediateUpdateEffect\n  });\n}\n\nexport default useMutationObserver;"]},"metadata":{},"sourceType":"module"}